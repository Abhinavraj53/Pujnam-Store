const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
require('dotenv').config();

const app = express();

// CORS Configuration - Must be the first middleware
const corsOptions = {
  origin: function (origin, callback) {
    // Allowed origins - includes localhost for development and production URLs
    const allowedOrigins = [
      'http://localhost:5173',
      'http://localhost:3000',
      'http://127.0.0.1:5173',
      'http://127.0.0.1:3000',
      'https://pujnam-store.onrender.com',
      'https://pujnam-store-frontend.onrender.com',
      'https://*.onrender.com',
      'https://*.vercel.app',
      'https://*.netlify.app'
    ];
    
    // Allow requests with no origin (like mobile apps, Postman, curl)
    if (!origin) {
      return callback(null, true);
    }
    
    // Check if origin is in allowed list
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else if (origin.includes('onrender.com') || origin.includes('vercel.app') || origin.includes('netlify.app')) {
      // Allow any Render, Vercel, or Netlify subdomain
      callback(null, true);
    } else {
      // For development, allow all origins
      callback(null, true);
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH', 'HEAD'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'Accept',
    'Origin',
    'Access-Control-Request-Method',
    'Access-Control-Request-Headers'
  ],
  exposedHeaders: ['Content-Range', 'X-Content-Range'],
  preflightContinue: false,
  optionsSuccessStatus: 204
};

// Apply CORS middleware
app.use(cors(corsOptions));

// Body parser middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Request logging middleware (for debugging)
app.use((req, res, next) => {
  console.log(`${req.method} ${req.path} - Origin: ${req.headers.origin || 'No origin'}`);
  next();
});

// MongoDB Connection
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb+srv://pujnamstore_db_user:1LdZi3kdzQbuR70g@cluster0.l1hh67m.mongodb.net/pujnam_store?retryWrites=true&w=majority';

// MongoDB connection options
const mongooseOptions = {
  serverSelectionTimeoutMS: 30000, // 30 seconds
  socketTimeoutMS: 45000, // 45 seconds
  connectTimeoutMS: 30000, // 30 seconds
  maxPoolSize: 10,
  retryWrites: true,
  w: 'majority'
};

mongoose.connect(MONGODB_URI, mongooseOptions)
  .then(() => {
    console.log('âœ… Connected to MongoDB Atlas');
    console.log(`ðŸ“Š Database: ${mongoose.connection.name}`);
  })
  .catch((err) => {
    console.error('âŒ MongoDB connection error:', err.message);
    console.error('ðŸ’¡ Make sure:');
    console.error('   1. Your IP is whitelisted in MongoDB Atlas');
    console.error('   2. MongoDB Atlas cluster is running');
    console.error('   3. Network connection is stable');
  });

// Handle connection events
mongoose.connection.on('error', (err) => {
  console.error('âŒ MongoDB connection error:', err);
});

mongoose.connection.on('disconnected', () => {
  console.warn('âš ï¸  MongoDB disconnected. Attempting to reconnect...');
});

mongoose.connection.on('reconnected', () => {
  console.log('âœ… MongoDB reconnected');
});

// Import Routes
const authRoutes = require('./routes/auth');
const productRoutes = require('./routes/products');
const categoryRoutes = require('./routes/categories');
const orderRoutes = require('./routes/orders');
const cartRoutes = require('./routes/cart');
const bannerRoutes = require('./routes/banners');
const panchangRoutes = require('./routes/panchang');
const couponRoutes = require('./routes/coupons');
const customerRoutes = require('./routes/customers');
const settingsRoutes = require('./routes/settings');
const festivalRoutes = require('./routes/festivals');
const uploadRoutes = require('./routes/upload');
const promoBlockRoutes = require('./routes/promoBlocks');
const sectionVideoRoutes = require('./routes/sectionVideos');

// Use Routes
app.use('/api/auth', authRoutes);
app.use('/api/products', productRoutes);
app.use('/api/categories', categoryRoutes);
app.use('/api/orders', orderRoutes);
app.use('/api/cart', cartRoutes);
app.use('/api/banners', bannerRoutes);
app.use('/api/panchang', panchangRoutes);
app.use('/api/coupons', couponRoutes);
app.use('/api/customers', customerRoutes);
app.use('/api/settings', settingsRoutes);
app.use('/api/festivals', festivalRoutes);
app.use('/api/upload', uploadRoutes);
app.use('/api/promo-blocks', promoBlockRoutes);
app.use('/api/section-videos', sectionVideoRoutes);

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', message: 'Pujnam Store API is running' });
});

// Diagnostic endpoint to check email service configuration (for debugging)
app.get('/api/diagnostics/email', (req, res) => {
  const isRender = !!(
    process.env.RENDER || 
    process.env.RENDER_EXTERNAL_URL || 
    process.env.RENDER_SERVICE_NAME
  );
  
  res.json({
    environment: {
      isRender: isRender,
      nodeEnv: process.env.NODE_ENV || 'development',
      hasRenderEnv: !!process.env.RENDER,
      hasRenderUrl: !!process.env.RENDER_EXTERNAL_URL,
      hasRenderService: !!process.env.RENDER_SERVICE_NAME
    },
    emailServices: {
      hostinger: {
        configured: !!(process.env.HOSTINGER_EMAIL_USER && process.env.HOSTINGER_EMAIL_PASSWORD),
        hasUser: !!process.env.HOSTINGER_EMAIL_USER,
        hasPassword: !!process.env.HOSTINGER_EMAIL_PASSWORD,
        port: process.env.HOSTINGER_SMTP_PORT || 'not set'
      },
    },
    recommendedService: 'Hostinger SMTP (Primary)'
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Error:', err.stack);
  res.status(500).json({ error: 'Something went wrong!', message: err.message });
});

// Render automatically sets PORT environment variable
// We use it directly - no need to set manually
const PORT = process.env.PORT || 5001;
const HOST = '0.0.0.0'; // Always bind to 0.0.0.0 for Render

// Log environment variables status (without exposing sensitive data)
console.log(`ðŸ“¦ Environment: ${process.env.NODE_ENV || 'development'}`);
console.log(`ðŸ”Œ PORT from Render: ${process.env.PORT || 'Not set (using default 5001)'}`);
console.log(`ðŸŒ Binding to: ${HOST}:${PORT}`);

// Start server only after MongoDB connection is established or after timeout
const startServer = () => {
  app.listen(PORT, HOST, () => {
    console.log(`âœ… Server successfully started on http://${HOST}:${PORT}`);
    console.log(`ðŸš€ Backend API is ready at: http://${HOST}:${PORT}/api`);
    console.log(`ðŸ“¡ CORS enabled for production domains`);
    console.log(`\nâš ï¸  Note: If you see database errors, check:`);
    console.log(`   1. MongoDB Atlas IP whitelist includes 0.0.0.0/0 (all IPs)`);
    console.log(`   2. MongoDB Atlas cluster is running`);
    console.log(`   3. MONGODB_URI environment variable is set correctly\n`);
  });
};

// Wait for MongoDB connection or start server anyway after 5 seconds
const connectionTimeout = setTimeout(() => {
  if (mongoose.connection.readyState === 0) {
    console.warn('âš ï¸  Starting server without MongoDB connection. Some features may not work.');
    startServer();
  }
}, 5000);

mongoose.connection.once('connected', () => {
  clearTimeout(connectionTimeout);
  startServer();
});

// If already connected, start immediately
if (mongoose.connection.readyState === 1) {
  clearTimeout(connectionTimeout);
  startServer();
}
